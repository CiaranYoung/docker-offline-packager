# # # name: Docker镜像智能打包离线包

# # # on:
# # #   workflow_dispatch:
# # #     inputs:
# # #       docker_images:
# # #         description: '请填写 Docker 镜像名称 (多个用英文逗号分开)'
# # #         required: true
# # #         default: 'alpine:latest'
# # #       tag:
# # #         description: '可选: 发布标签 (默认为当前日期)'
# # #         required: false
# # #       custom_name:
# # #         description: '可选: 自定义归档名称（仅在多个镜像时使用）'
# # #         required: false
# # #       platform:
# # #         description: '可选: 指定 Docker 镜像的架构 (例如 linux/amd64, linux/arm64, linux/386 等)'
# # #         required: false
# # #         default: 'linux/amd64'

# # # jobs:
# # #   pull_and_package:
# # #     runs-on: ubuntu-latest

# # #     steps:
# # #     - name: 检出存储库
# # #       uses: actions/checkout@v4

# # #     - name: 设置 Docker Buildx
# # #       uses: docker/setup-buildx-action@v3

# # #     - name: 创建构建器并使用它
# # #       run: |
# # #         docker buildx create --use

# # #     - name: 安装 QEMU 以获得多架构支持
# # #       uses: docker/setup-qemu-action@v3

# # #     - name: 清理 Docker 以释放空间
# # #       run: |
# # #         docker system prune -a -f
# # #         docker volume prune -f

# # #     # - name: 拉取并保存指定架构的 Docker 镜像
# # #     #   run: |
# # #     #     images="${{ github.event.inputs.docker_images }}"
# # #     #     platform="${{ github.event.inputs.platform }}"
# # #     #     IFS=',' read -r -a image_array <<< "$images"
# # #     #     for image in "${image_array[@]}"; do
# # #     #       image_name_with_registry="${image%%:*}"
# # #     #       image_name="${image_name_with_registry##*/}"
# # #     #       image_tag="${image##*:}"

# # #     #       file_name="${image_name}.tar"
# # #     #       docker pull --platform "$platform" "${image}"
# # #     #       docker save "${image}" -o "${file_name}"
# # #     #     done

# # #     # - name: 拉取并保存指定架构的 Docker 镜像
# # #     #   run: |
# # #     #     images="${{ github.event.inputs.docker_images }}"
# # #     #     platform="${{ github.event.inputs.platform }}"
# # #     #     IFS=',' read -r -a image_array <<< "$images"

# # #     #     for image in "${image_array[@]}"; do
# # #     #       # 去除镜像名称中的空格
# # #     #       image="$(echo "$image" | xargs)"

# # #     #       # 使用完整镜像名称生成文件名，将 "/" 替换为 "-"
# # #     #       image_file_name="${image//\//-}.tar"
          
# # #     #       # 拉取并保存镜像
# # #     #       echo "Pulling $image for platform $platform..."
# # #     #       docker pull --platform "$platform" "$image"
          
# # #     #       echo "Saving $image as $image_file_name..."
# # #     #       docker save "$image" -o "$image_file_name"
# # #     #     done

# # #     - name: 拉取并保存指定架构的 Docker 镜像
# # #       run: |
# # #         set -e  # 任何错误都会导致脚本退出
# # #         images="${{ github.event.inputs.docker_images }}"
# # #         platform="${{ github.event.inputs.platform }}"
# # #         IFS=',' read -r -a image_array <<< "$images"

# # #         echo "准备处理的镜像列表: ${image_array[@]}"
# # #         echo "目标平台: $platform"

# # #         for image in "${image_array[@]}"; do
# # #           # 去除镜像名称中的前后空格和任何回车符
# # #           image="$(echo "$image" | tr -d '\r' | xargs)"
          
# # #           echo "正在处理镜像: '$image'"

# # #           # 检查镜像名称是否为空
# # #           if [ -z "$image" ]; then
# # #             echo "跳过空的镜像条目。"
# # #             continue
# # #           fi

# # #           # 检查镜像是否包含标签，如果没有则添加默认标签 ':latest'
# # #           if [[ "$image" != *:* ]]; then
# # #             echo "镜像 '$image' 缺少标签，自动添加 ':latest' 标签。"
# # #             image="${image}:latest"
# # #           fi

# # #           # 生成文件名，替换 '/' 为 '-' 以避免文件系统路径问题
# # #           image_file_name="${image//\//-}.tar"
          
# # #           echo "正在拉取镜像: $image for platform: $platform..."
# # #           docker pull --platform "$platform" "$image"

# # #           echo "正在保存镜像: $image 为文件: $image_file_name..."
# # #           docker save "$image" -o "$image_file_name"

# # #           echo "成功保存 $image 到 $image_file_name"
# # #         done

# # #     - name: 列出要调试的文件
# # #       run: |
# # #         ls -lh

# # #     - name: 确定文件处理逻辑
# # #       id: determine_logic
# # #       run: |
# # #         images="${{ github.event.inputs.docker_images }}"
# # #         IFS=',' read -r -a image_array <<< "$images"
# # #         num_images=${#image_array[@]}

# # #         if [ $num_images -eq 1 ]; then
# # #           single_file="${image_array[0]%%:*}"
# # #           single_file="${single_file##*/}.tar"
# # #           echo "RELEASE_NAME=${single_file}" >> $GITHUB_ENV
# # #           echo "num_images=1" >> $GITHUB_OUTPUT
# # #         else
# # #           if [ -z "${{ github.event.inputs.custom_name }}" ]; then
# # #             archive_name="$(date +'%Y%m%d').tar.gz"
# # #           else
# # #             archive_name="${{ github.event.inputs.custom_name }}.tar.gz"
# # #           fi
# # #           echo "RELEASE_NAME=${archive_name}" >> $GITHUB_ENV
# # #           echo "num_images=$num_images" >> $GITHUB_OUTPUT
# # #         fi

# # #     - name: 必要时进行压缩
# # #       if: steps.determine_logic.outputs.num_images > 1
# # #       run: |
# # #         tar -czf "${{ env.RELEASE_NAME }}" *.tar

# # #     - name: 检查文件大小
# # #       id: check_size
# # #       run: |
# # #         file="${{ env.RELEASE_NAME }}"
# # #         file_size=$(stat -c%s "$file")
# # #         max_size=$((2 * 1024 * 1024 * 1024))

# # #         if [ "$file_size" -gt "$max_size" ]; then
# # #           echo "EXCEEDS_LIMIT=true" >> $GITHUB_ENV
# # #         else
# # #           echo "EXCEEDS_LIMIT=false" >> $GITHUB_ENV
# # #         fi

# # #     - name: 获取发布名称和标签
# # #       run: |
# # #         if [ ${{ steps.determine_logic.outputs.num_images }} -gt 1 ]; then
# # #           if [ -z "${{ github.event.inputs.custom_name }}" ]; then
# # #             release_name="${{ env.RELEASE_NAME }}"
# # #           else
# # #             release_name="${{ github.event.inputs.custom_name }}.tar.gz"
# # #           fi
# # #         else
# # #           release_name="${{ env.RELEASE_NAME }}"
# # #         fi
# # #         echo "RELEASE_NAME=$release_name" >> $GITHUB_ENV

# # #         if [ -z "${{ github.event.inputs.tag }}" ]; then
# # #           tag_name=$(date +'%Y%m%d')
# # #         else
# # #           tag_name="${{ github.event.inputs.tag }}"
# # #         fi
# # #         echo "RELEASE_TAG=$tag_name" >> $GITHUB_ENV

# # #     - name: 上传至 GitHub Release（如果小于2GB）
# # #       if: env.EXCEEDS_LIMIT == 'false'
# # #       uses: softprops/action-gh-release@v2
# # #       with:
# # #         tag_name: ${{ env.RELEASE_TAG }}
# # #         files: ${{ env.RELEASE_NAME }}
# # #         body: "Daily Docker Images for ${{ env.RELEASE_TAG }}"
# # #         token: ${{ secrets.GITHUB_TOKEN }}

# # #     - name: 上传为工件（如果超过2GB）
# # #       if: env.EXCEEDS_LIMIT == 'true'
# # #       uses: actions/upload-artifact@v4
# # #       with:
# # #         name: ${{ env.RELEASE_NAME }}
# # #         path: ${{ env.RELEASE_NAME }}

# # #     - name: 清理中间文件（如果小于2GB）
# # #       if: env.EXCEEDS_LIMIT == 'false'
# # #       run: |
# # #         rm *.tar

# # name: Docker镜像智能打包离线包

# # on:
# #   workflow_dispatch:
# #     inputs:
# #       docker_images:
# #         description: '请填写 Docker 镜像名称 (多个用英文逗号分开)'
# #         required: true
# #         default: 'alpine:latest'
# #       tag:
# #         description: '可选: 发布标签 (默认为当前日期)'
# #         required: false
# #       custom_name:
# #         description: '可选: 自定义归档名称（仅在多个镜像时使用）'
# #         required: false
# #       platform:
# #         description: '可选: 指定 Docker 镜像的架构 (例如 linux/amd64, linux/arm64, linux/386 等)'
# #         required: false
# #         default: 'linux/amd64'

# # jobs:
# #   pull_and_package:
# #     runs-on: ubuntu-latest

# #     steps:
# #     - name: 检出存储库
# #       uses: actions/checkout@v4

# #     - name: 设置 Docker Buildx
# #       uses: docker/setup-buildx-action@v3

# #     - name: 创建构建器并使用它
# #       run: |
# #         docker buildx create --use

# #     - name: 安装 QEMU 以获得多架构支持
# #       uses: docker/setup-qemu-action@v3

# #     - name: 清理 Docker 以释放空间
# #       run: |
# #         docker system prune -a -f
# #         docker volume prune -f

# #     - name: 显示磁盘使用情况（开始）
# #       run: df -h

# #     - name: 拉取并保存指定架构的 Docker 镜像
# #       run: |
# #         set -e  # 任何错误都会导致脚本退出
# #         images="${{ github.event.inputs.docker_images }}"
# #         platform="${{ github.event.inputs.platform }}"
# #         IFS=',' read -r -a image_array <<< "$images"

# #         echo "准备处理的镜像列表: ${image_array[@]}"
# #         echo "目标平台: $platform"

# #         for image in "${image_array[@]}"; do
# #           # 去除镜像名称中的前后空格和任何回车符
# #           image="$(echo "$image" | tr -d '\r' | xargs)"
          
# #           echo "正在处理镜像: '$image'"

# #           # 检查镜像名称是否为空
# #           if [ -z "$image" ]; then
# #             echo "跳过空的镜像条目。"
# #             continue
# #           fi

# #           # 检查镜像是否包含标签，如果没有则添加默认标签 ':latest'
# #           if [[ "$image" != *:* ]]; then
# #             echo "镜像 '$image' 缺少标签，自动添加 ':latest' 标签。"
# #             image="${image}:latest"
# #           fi

# #           # 生成文件名，替换 '/' 为 '-' 以避免文件系统路径问题，并添加压缩扩展名
# #           image_file_name="${image//\//-}.tar.gz"
          
# #           echo "正在拉取镜像: $image for platform: $platform..."
# #           docker pull --platform "$platform" "$image"

# #           echo "正在保存并压缩镜像: $image 为文件: $image_file_name..."
# #           docker save "$image" | gzip > "$image_file_name"

# #           echo "成功保存 $image 到 $image_file_name"

# #           echo "删除镜像: $image 以释放空间..."
# #           docker rmi "$image" || true  # 如果镜像已被其他容器使用，忽略错误

# #           echo "当前磁盘使用情况："
# #           df -h
# #         done

# #     - name: 列出要调试的文件
# #       run: |
# #         ls -lh

# #     - name: 确定文件处理逻辑
# #       id: determine_logic
# #       run: |
# #         images="${{ github.event.inputs.docker_images }}"
# #         IFS=',' read -r -a image_array <<< "$images"
# #         num_images=${#image_array[@]}

# #         if [ $num_images -eq 1 ]; then
# #           single_file="${image_array[0]%%:*}"
# #           single_file="${single_file##*/}.tar.gz"
# #           echo "RELEASE_NAME=${single_file}" >> $GITHUB_ENV
# #           echo "num_images=1" >> $GITHUB_OUTPUT
# #         else
# #           if [ -z "${{ github.event.inputs.custom_name }}" ]; then
# #             archive_name="$(date +'%Y%m%d').tar.gz"
# #           else
# #             archive_name="${{ github.event.inputs.custom_name }}.tar.gz"
# #           fi
# #           echo "RELEASE_NAME=${archive_name}" >> $GITHUB_ENV
# #           echo "num_images=$num_images" >> $GITHUB_OUTPUT
# #         fi

# #     - name: 必要时进行压缩
# #       if: steps.determine_logic.outputs.num_images > 1
# #       run: |
# #         tar -czf "${{ env.RELEASE_NAME }}" *.tar.gz

# #     - name: 检查文件大小
# #       id: check_size
# #       run: |
# #         file="${{ env.RELEASE_NAME }}"
# #         file_size=$(stat -c%s "$file")
# #         max_size=$((2 * 1024 * 1024 * 1024))

# #         if [ "$file_size" -gt "$max_size" ]; then
# #           echo "EXCEEDS_LIMIT=true" >> $GITHUB_ENV
# #         else
# #           echo "EXCEEDS_LIMIT=false" >> $GITHUB_ENV
# #         fi

# #     - name: 获取发布名称和标签
# #       run: |
# #         if [ ${{ steps.determine_logic.outputs.num_images }} -gt 1 ]; then
# #           if [ -z "${{ github.event.inputs.custom_name }}" ]; then
# #             release_name="${{ env.RELEASE_NAME }}"
# #           else
# #             release_name="${{ github.event.inputs.custom_name }}.tar.gz"
# #           fi
# #         else
# #           release_name="${{ env.RELEASE_NAME }}"
# #         fi
# #         echo "RELEASE_NAME=$release_name" >> $GITHUB_ENV

# #         if [ -z "${{ github.event.inputs.tag }}" ]; then
# #           tag_name=$(date +'%Y%m%d')
# #         else
# #           tag_name="${{ github.event.inputs.tag }}"
# #         fi
# #         echo "RELEASE_TAG=$tag_name" >> $GITHUB_ENV

# #     - name: 上传至 GitHub Release（如果小于2GB）
# #       if: env.EXCEEDS_LIMIT == 'false'
# #       uses: softprops/action-gh-release@v2
# #       with:
# #         tag_name: ${{ env.RELEASE_TAG }}
# #         files: ${{ env.RELEASE_NAME }}
# #         body: "Daily Docker Images for ${{ env.RELEASE_TAG }}"
# #         token: ${{ secrets.GITHUB_TOKEN }}

# #     - name: 上传为工件（如果超过2GB）
# #       if: env.EXCEEDS_LIMIT == 'true'
# #       uses: actions/upload-artifact@v4
# #       with:
# #         name: ${{ env.RELEASE_NAME }}
# #         path: ${{ env.RELEASE_NAME }}

# #     - name: 清理中间文件（如果小于2GB）
# #       if: env.EXCEEDS_LIMIT == 'false'
# #       run: |
# #         rm *.tar.gz
# name: Docker镜像智能打包离线包

# on:
#   workflow_dispatch:
#     inputs:
#       docker_images:
#         description: '请填写 Docker 镜像名称 (多个用英文逗号分开)'
#         required: true
#         default: 'alpine:latest'
#       tag:
#         description: '可选: 发布标签 (默认为当前日期)'
#         required: false
#       custom_name:
#         description: '可选: 自定义归档名称（仅在多个镜像时使用）'
#         required: false
#       platform:
#         description: '可选: 指定 Docker 镜像的架构 (例如 linux/amd64, linux/arm64, linux/386 等)'
#         required: false
#         default: 'linux/amd64'

# jobs:
#   pull_and_package:
#     runs-on: ubuntu-latest

#     steps:
#     - name: 检出存储库
#       uses: actions/checkout@v4

#     - name: 设置 Docker Buildx
#       uses: docker/setup-buildx-action@v3

#     - name: 创建构建器并使用它
#       run: |
#         docker buildx create --use

#     - name: 安装 QEMU 以获得多架构支持
#       uses: docker/setup-qemu-action@v3

#     - name: 清理 Docker 以释放空间
#       run: |
#         docker system prune -a -f
#         docker volume prune -f

#     - name: 确保 /mnt 目录可写
#       run: |
#         mkdir -p /mnt
#         chmod 777 /mnt

#     - name: 显示磁盘使用情况（开始）
#       run: df -h

#     - name: 拉取并保存指定架构的 Docker 镜像
#       run: |
#         set -e  # 任何错误都会导致脚本退出
#         images="${{ github.event.inputs.docker_images }}"
#         platform="${{ github.event.inputs.platform }}"
#         IFS=',' read -r -a image_array <<< "$images"

#         echo "准备处理的镜像列表: ${image_array[@]}"
#         echo "目标平台: $platform"

#         for image in "${image_array[@]}"; do
#           # 去除镜像名称中的前后空格和任何回车符
#           image="$(echo "$image" | tr -d '\r' | xargs)"
          
#           echo "正在处理镜像: '$image'"

#           # 检查镜像名称是否为空
#           if [ -z "$image" ]; then
#             echo "跳过空的镜像条目。"
#             continue
#           fi

#           # 检查镜像是否包含标签，如果没有则添加默认标签 ':latest'
#           if [[ "$image" != *:* ]]; then
#             echo "镜像 '$image' 缺少标签，自动添加 ':latest' 标签。"
#             image="${image}:latest"
#           fi

#           # 生成文件名，替换 '/' 为 '-' 以避免文件系统路径问题，并添加压缩扩展名
#           image_file_name="${image//\//-}.tar.gz"

#           echo "正在拉取镜像: $image for platform: $platform..."
#           docker pull --platform "$platform" "$image"

#           echo "正在检查可用空间..."
#           avail_root=$(df --output=avail -B1 / | tail -1)
#           avail_mnt=$(df --output=avail -B1 /mnt | tail -1)

#           # 获取镜像大小
#           image_size=$(docker image inspect "$image" --format='{{.Size}}')

#           echo "镜像大小: $image_size bytes"
#           echo "/ 可用空间: $avail_root bytes"
#           echo "/mnt 可用空间: $avail_mnt bytes"

#           # 决定保存路径
#           if [ "$avail_root" -ge "$image_size" ]; then
#             save_path="/${image_file_name}"
#             echo "保存到根文件系统: $save_path"
#           elif [ "$avail_mnt" -ge "$image_size" ]; then
#             save_path="/mnt/${image_file_name}"
#             echo "保存到 /mnt: $save_path"
#           else
#             echo "没有足够的空间保存镜像: $image"
#             exit 1
#           fi

#           # 保存并压缩镜像
#           echo "保存并压缩镜像到: $save_path"
#           docker save "$image" | gzip > "$save_path"

#           echo "成功保存 $image 到 $save_path"

#           # 删除镜像以释放空间
#           echo "删除镜像: $image 以释放空间..."
#           docker rmi "$image" || true

#           echo "当前磁盘使用情况："
#           df -h
#         done

#     - name: 列出要调试的文件
#       run: |
#         ls -lh /mnt
#         ls -lh /

#     - name: 确定文件处理逻辑
#       id: determine_logic
#       run: |
#         images="${{ github.event.inputs.docker_images }}"
#         IFS=',' read -r -a image_array <<< "$images"
#         num_images=${#image_array[@]}

#         if [ $num_images -eq 1 ]; then
#           single_file="${image_array[0]%%:*}"
#           single_file="${single_file##*/}.tar.gz"
#           echo "RELEASE_NAME=/mnt/${single_file}" >> $GITHUB_ENV
#           echo "num_images=1" >> $GITHUB_OUTPUT
#         else
#           if [ -z "${{ github.event.inputs.custom_name }}" ]; then
#             archive_name="/mnt/$(date +'%Y%m%d').tar.gz"
#           else
#             archive_name="/mnt/${{ github.event.inputs.custom_name }}.tar.gz"
#           fi
#           echo "RELEASE_NAME=${archive_name}" >> $GITHUB_ENV
#           echo "num_images=$num_images" >> $GITHUB_OUTPUT
#         fi

#     - name: 必要时进行压缩
#       if: steps.determine_logic.outputs.num_images > 1
#       run: |
#         tar -czf "${{ env.RELEASE_NAME }}" /mnt/*.tar.gz

#     - name: 检查文件大小
#       id: check_size
#       run: |
#         file="${{ env.RELEASE_NAME }}"
#         file_size=$(stat -c%s "$file")
#         max_size=$((2 * 1024 * 1024 * 1024))  # 2GB

#         if [ "$file_size" -gt "$max_size" ]; then
#           echo "EXCEEDS_LIMIT=true" >> $GITHUB_ENV
#         else
#           echo "EXCEEDS_LIMIT=false" >> $GITHUB_ENV
#         fi

#     - name: 获取发布名称和标签
#       run: |
#         if [ ${{ steps.determine_logic.outputs.num_images }} -gt 1 ]; then
#           if [ -z "${{ github.event.inputs.custom_name }}" ]; then
#             release_name="${{ env.RELEASE_NAME }}"
#           else
#             release_name="${{ github.event.inputs.custom_name }}.tar.gz"
#           fi
#         else
#           release_name="${{ env.RELEASE_NAME }}"
#         fi
#         echo "RELEASE_NAME=$release_name" >> $GITHUB_ENV

#         if [ -z "${{ github.event.inputs.tag }}" ]; then
#           tag_name=$(date +'%Y%m%d')
#         else
#           tag_name="${{ github.event.inputs.tag }}"
#         fi
#         echo "RELEASE_TAG=$tag_name" >> $GITHUB_ENV

#     - name: 上传至 GitHub Release（如果小于2GB）
#       if: env.EXCEEDS_LIMIT == 'false'
#       uses: softprops/action-gh-release@v2
#       with:
#         tag_name: ${{ env.RELEASE_TAG }}
#         files: ${{ env.RELEASE_NAME }}
#         body: "Daily Docker Images for ${{ env.RELEASE_TAG }}"
#         token: ${{ secrets.GITHUB_TOKEN }}

#     - name: 上传为工件（如果超过2GB）
#       if: env.EXCEEDS_LIMIT == 'true'
#       uses: actions/upload-artifact@v4
#       with:
#         name: ${{ env.RELEASE_NAME }}
#         path: ${{ env.RELEASE_NAME }}

#     - name: 清理中间文件（如果小于2GB）
#       if: env.EXCEEDS_LIMIT == 'false'
#       run: |
#         rm /mnt/*.tar.gz
name: Docker镜像智能打包离线包

on:
  workflow_dispatch:
    inputs:
      docker_images:
        description: '请填写 Docker 镜像名称 (多个用英文逗号分开)'
        required: true
        default: 'alpine:latest'
      tag:
        description: '可选: 发布标签 (默认为当前日期)'
        required: false
      custom_name:
        description: '可选: 自定义归档名称（仅在多个镜像时使用）'
        required: false
      platform:
        description: '可选: 指定 Docker 镜像的架构 (例如 linux/amd64, linux/arm64, linux/386 等)'
        required: false
        default: 'linux/amd64'

jobs:
  pull_and_package:
    runs-on: ubuntu-latest

    steps:
    - name: 检出存储库
      uses: actions/checkout@v4

    - name: 设置 Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: 创建构建器并使用它
      run: |
        docker buildx create --use

    - name: 安装 QEMU 以获得多架构支持
      uses: docker/setup-qemu-action@v3

    - name: 清理 Docker 以释放空间
      run: |
        docker system prune -a -f
        docker volume prune -f

    - name: 确保 /mnt 目录可写
      run: |
        mkdir -p /mnt
        ls -ld /mnt

    - name: 显示磁盘使用情况（开始）
      run: df -h

    - name: 拉取并保存指定架构的 Docker 镜像
      run: |
        set -e  # 任何错误都会导致脚本退出
        images="${{ github.event.inputs.docker_images }}"
        platform="${{ github.event.inputs.platform }}"
        IFS=',' read -r -a image_array <<< "$images"

        echo "准备处理的镜像列表: ${image_array[@]}"
        echo "目标平台: $platform"

        for image in "${image_array[@]}"; do
          # 去除镜像名称中的前后空格和任何回车符
          image="$(echo "$image" | tr -d '\r' | xargs)"
          
          echo "正在处理镜像: '$image'"

          # 检查镜像名称是否为空
          if [ -z "$image" ]; then
            echo "跳过空的镜像条目。"
            continue
          fi

          # 检查镜像是否包含标签，如果没有则添加默认标签 ':latest'
          if [[ "$image" != *:* ]]; then
            echo "镜像 '$image' 缺少标签，自动添加 ':latest' 标签。"
            image="${image}:latest"
          fi

          # 生成文件名，替换 '/' 为 '-' 以避免文件系统路径问题，并添加压缩扩展名
          image_file_name="${image//\//-}.tar.gz"
          
          echo "正在拉取镜像: $image for platform: $platform..."
          docker pull --platform "$platform" "$image"

          echo "正在检查可用空间..."
          avail_root=$(df --output=avail -B1 / | tail -1)
          avail_mnt=$(df --output=avail -B1 /mnt | tail -1)

          # 获取镜像大小
          image_size=$(docker image inspect "$image" --format='{{.Size}}')

          echo "镜像大小: $image_size bytes"
          echo "/ 可用空间: $avail_root bytes"
          echo "/mnt 可用空间: $avail_mnt bytes"

          # 决定保存路径
          if [ "$avail_root" -ge "$image_size" ]; then
            save_path="/${image_file_name}"
            echo "保存到根文件系统: $save_path"
          elif [ "$avail_mnt" -ge "$image_size" ]; then
            save_path="/mnt/${image_file_name}"
            echo "保存到 /mnt: $save_path"
          else
            echo "没有足够的空间保存镜像: $image"
            exit 1
          fi

          # 保存并压缩镜像
          echo "保存并压缩镜像到: $save_path"
          docker save "$image" | gzip > "$save_path"

          echo "成功保存 $image 到 $save_path"

          # 删除镜像以释放空间
          echo "删除镜像: $image 以释放空间..."
          docker rmi "$image" || true

          echo "当前磁盘使用情况："
          df -h
        done

    - name: 列出要调试的文件
      run: |
        ls -lh /mnt
        ls -lh /

    - name: 确定文件处理逻辑
      id: determine_logic
      run: |
        images="${{ github.event.inputs.docker_images }}"
        IFS=',' read -r -a image_array <<< "$images"
        num_images=${#image_array[@]}

        if [ $num_images -eq 1 ]; then
          single_file="${image_array[0]%%:*}"
          single_file="${single_file##*/}.tar.gz"
          # 判断保存路径
          if [ -f "/mnt/${single_file}" ]; then
            echo "RELEASE_NAME=/mnt/${single_file}" >> $GITHUB_ENV
          else
            echo "RELEASE_NAME=/${single_file}" >> $GITHUB_ENV
          fi
          echo "num_images=1" >> $GITHUB_OUTPUT
        else
          if [ -z "${{ github.event.inputs.custom_name }}" ]; then
            archive_name="/mnt/$(date +'%Y%m%d').tar.gz"
          else
            archive_name="/mnt/${{ github.event.inputs.custom_name }}.tar.gz"
          fi
          echo "RELEASE_NAME=${archive_name}" >> $GITHUB_ENV
          echo "num_images=$num_images" >> $GITHUB_OUTPUT
        fi

    - name: 必要时进行压缩
      if: steps.determine_logic.outputs.num_images > 1
      run: |
        tar -czf "${{ env.RELEASE_NAME }}" /mnt/*.tar.gz

    - name: 检查文件大小
      id: check_size
      run: |
        file="${{ env.RELEASE_NAME }}"
        file_size=$(stat -c%s "$file")
        max_size=$((2 * 1024 * 1024 * 1024))  # 2GB

        if [ "$file_size" -gt "$max_size" ]; then
          echo "EXCEEDS_LIMIT=true" >> $GITHUB_ENV
        else
          echo "EXCEEDS_LIMIT=false" >> $GITHUB_ENV
        fi

    - name: 获取发布名称和标签
      run: |
        if [ ${{ steps.determine_logic.outputs.num_images }} -gt 1 ]; then
          if [ -z "${{ github.event.inputs.custom_name }}" ]; then
            release_name="${{ env.RELEASE_NAME }}"
          else
            release_name="${{ github.event.inputs.custom_name }}.tar.gz"
          fi
        else
          release_name="${{ env.RELEASE_NAME }}"
        fi
        echo "RELEASE_NAME=$release_name" >> $GITHUB_ENV

        if [ -z "${{ github.event.inputs.tag }}" ]; then
          tag_name=$(date +'%Y%m%d')
        else
          tag_name="${{ github.event.inputs.tag }}"
        fi
        echo "RELEASE_TAG=$tag_name" >> $GITHUB_ENV

    - name: 上传至 GitHub Release（如果小于2GB）
      if: env.EXCEEDS_LIMIT == 'false'
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ env.RELEASE_TAG }}
        files: ${{ env.RELEASE_NAME }}
        body: "Daily Docker Images for ${{ env.RELEASE_TAG }}"
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: 上传为工件（如果超过2GB）
      if: env.EXCEEDS_LIMIT == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.RELEASE_NAME }}
        path: ${{ env.RELEASE_NAME }}

    - name: 清理中间文件（如果小于2GB）
      if: env.EXCEEDS_LIMIT == 'false'
      run: |
        rm /mnt/*.tar.gz

